# ES2018 (ES9)

ECMAScript 2018 was released in June 2018, add fewer features than major editions(ES2016, ES2017) used to.
These new changes are explained in next subsections.

## Asynchronous Iteration

With synchronous iteratios, we are able to iterating data, but not when data if fron an asynchronoys source. For example from https fetch.

We will start with a recap synchronous iteration and then look at new asynchronous iteration.

### Synchronous iteration

Synchronous iteration was introduced with ES6 and have the next components

* Iterable: Is an object that can be iteralble via a method whse key is Symbol.iterator
* Iterator: An object returned by \[Symbol.iterator](). It have a method .next() that return the next element
* NextElement: Is the object returned by .next(). It have 2 properties:
  * Value: Contais de value to be used.
  * Done: Becomes true after the last element.

If you need some extra info about Iterator patter. Check this [link](https://refactoring.guru/design-patterns/iterator)

### Asynchronous Iteration

The previously explained way of iterating is synchronous, it doesn‚Äôt work for asynchronous sources. For example, in the following code, fetchCoinValues() cannot deliver its asynchronous data via synchronous iteration:

```javaScript
for (const coinValue of fetchCoinValues(['ETH','XMR','BTC','LTC','BAT'])) {
  console.log(coinValue);
}
```
The proposal specifies a new protocol for iteration that works asynchronously:

* Async iterables are marked via Symbol.asyncIterator.
* Method next() of an async iterator returns Promises or NextElement.

```javascript
for await (const coinValue of fetchCoinValues(['ETH','XMR','BTC','LTC','BAT'])) {
  console.log(coinValue);
}
```    
## Rest/Spread Properties 

We have a new (or two) operator. 
* The rest operator(...) is used in object destructuring.
* The spread operator(...) in object literals.

### Rest operator

Inside object destructuring patterns, the rest operator (...) copies all enumerable own properties of the destructuring source into its operand, except those that were already mentioned in the object literal.

```javascript
const foo = {
  empandas: 6,
  milanesas: 2,
  yerba: "1 Kg",
};

const { yerba, ...rest } = foo;

console.log(yerba) // Prints "1 Kg"
console.log(rest) // Prints {empandas: 6, milanesas: 2}
```

We can do it inside of a function to hande named parameters
```javascript
function func({yerba, ...rest}) { // rest operator
  // You can eat empanadas and drink mate here.
}
```

It have a syntaxis restriction that you can use the rest operator at most once and it must appear at the end.

```javascript
const  { ...rest, yerba } = foo; // syntax error
const  { ...rest, ...others } = foo; // syntax error
```

### Spread operator

side object literals, the spread operator (...) inserts all enumerable own properties of its operand into the object created via the literal:

```javascript
const foo = {
  empandas: 6,
  milanesas: 2,
  yerba: "1 Kg",
};

const bar = { ...foo, water: "1 L"  }

console.log(bar) // Prints 
/**
* {
*   emapnadas: 6,
*   milanesas: 2,
*   yerba: "1 Kg",
*   water: "1 L",
**/
```
If we have conflicts with keys, last one wins. This useful to override default keys.

```javascript
const foo = {
  empandas: 6,
  milanesas: 2,
  yerba: "1 Kg",
};

const bar = { ...foo, empanadas: 12  }

console.log(bar) // Prints 
/**
* {
*   emapnadas: 12,
*   milanesas: 2,
*   yerba: "1 Kg",
**/
```

## New features related to regular expression

This release, brings 4 new features to regulars expressions

### Flag s(dotAll)

Dot (`.`) in regular expressions

```javascript
console.log(/^.$/.test('\n')) // Prints false
```

DotAll allows `.` in a regExp to match line terminators ( `/n`) and emojis (`üòÅ`)

```javascript
console.log(/^.$/s.test('üòÅ')) // Prints true
```

### Unicode Property Escapes

Unicode standard assungs properties to each symbol. Now, we can access this properties inside of RegEXp. To access this properties, we need to use flag `u`.


```javascript
const result = /^\p{White_Space}+$/u.test('3 empanadas');

console.log(result) // Prints true
```

This new feature makes RegExp much more readeables. 

### Lookbehind Assertions 

A lookbehind assertion is denoted by `(?<=\$|¬£|‚Ç¨)`, and enables you to match a pattern based on the substring that precedes the pattern. For example,

```javascript
const regExp = /(?<=\$|¬£|‚Ç¨)\d+(\.\d*)?/;

console.log(regExp.exec('199')); // Prints null
console.log(regExp.exec('$199')[0]); // Prints 199
```

Also, we have the negative version replacing `=` with `!` that is `(?<!\$|¬£|‚Ç¨)`

```javascript
const negativeRegExp = /(?<!\$|¬£|‚Ç¨)\d+(\.\d*)?/;

```

### named capture groups

Numbered capture groups enable you to take apart a string with a regular expression.

Successfully matching a regular expression against a string returns a match object matchObj. Putting a fragment of the regular expression in parentheses turns that fragment into a capture group: the part of the string that it matches is stored in matchObj.

Prior to this proposal, all capture groups were accessed by number: the capture group starting with the first parenthesis via matchObj[1], the capture group starting with the second parenthesis via matchObj[2], etc.

```javascript
const RE_DATE = /([0-9]{4})-([0-9]{2})-([0-9]{2})/;

const matchObj = RE_DATE.exec('1988-05-27');
const year = matchObj[1]; // 1988
const month = matchObj[2]; // 05
const day = matchObj[3]; // 27
```

After this new feature, we can access this groups by name

```javascript
const RE_DATE = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;

const matchObj = RE_DATE.exec('1988-05-31');
const year = matchObj.groups.year; // 1988
const month = matchObj.groups.month; // 05
const day = matchObj.groups.day; // 27
```
it becames reaally interesting combined with destructuring

```javascript
const { groups: {day, month} } = RE_DATE.exec('1988-05-27');

console.log(day) // Prints 31
```

It bgrings a lot of benefits, like easier to find groups by ID(year, month, day), each group is now self desciptive and you don't have to change code if changes the order of the groups in the RegExp.

## Promise .finally

This new callback will always be executed, if catch was called or not.

```javascript
fetch(url)
  .then()
  .catch()
  .finally(() => console.log('I always run!'))
```
`.finally` is useful when you need to do some clean up after the operation has finished regardless of whether or not it succeeded,for example to close a connection. 

## Template literal revision

When a template literal is immediately preceded by an expression, it is called a tagged template literal. A tagged template comes in handy when you want to parse a template literal with a function. Consider the following example:

```javascript
function fn(string, substitute) {
  if(substitute === 'empanadas') {
    substitute = 'milanesas'
  }
  return substitute + string[1];
}

const food = 'empanadas';
const result = fn`${food} are tasty`;

console.log(result); // Prints milanesas was a major update
```

 had syntactic restrictions related to escape sequences. Examples are `\x` interpreted as a hex escape, a `\u` interpreted as a unicode escape, and a `\` followed by a digit interpreted as an octal escape. As a result, strings such as `C:\xxx\uuu` or `\ubuntu` were considered invalid escape sequences by the interpreter and would throw a SyntaxError. 

 ```javascript
 function fn(string, substitute) {
  console.log(substitute);    // Prints escape sequences:
  console.log(string[1]);     // Prints undefined
}

const str = 'escape sequences:';
const result = fn`${str} \ubuntu C:\xxx\uuu`;
```

Keep in mind that using illegal escape sequences in a regular template literal still causes an error:

```javascript
const result = `\ubuntu`; // SyntaxError: Invalid Unicode escape sequence
```

## Conclusions

This is a lot to digest, but each word, revision, feature and release will improve or programming skills.
Remeber that, having this in mind,*and using it*, our code will be **shorter** and **cleaner** than before.

## Soruces

* [Article by Bramus!](https://medium.com/front-end-weekly/javascript-whats-new-in-ecmascript-2018-es2018-17ede97f36d5)

* [Article by Flavio H. Freitas](https://medium.freecodecamp.org/es9-javascripts-state-of-art-in-2018-9a350643f29c)

* [css-tricks](https://css-tricks.com/new-es2018-features-every-javascript-developer-should-know/)

* [Article by Yeison Daza](https://yeisondaza.com/es2018-parte-1-mejoras-a-regexp)

* [2ality](http://2ality.com/archive.html?tag=es2018)